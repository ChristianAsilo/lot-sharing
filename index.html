<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <title>Cabuyao Map with Points</title>
  <style>
    html,
    body {
      margin: 0;
      overflow: hidden;
      width: 100%;
      height: 100%;
    }

    canvas {
      display: block;
    }
  </style>
</head>

<body>
  <canvas id="webgl"></canvas>

  <script type="module">
    import * as THREE from 'three';
    import { Line2 } from 'three/addons/lines/Line2.js';
    import { LineMaterial } from 'three/addons/lines/LineMaterial.js';
    import { LineGeometry } from 'three/addons/lines/LineGeometry.js';

    const canvas = document.getElementById('webgl');
    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);

    const scene = new THREE.Scene();

    const camera = new THREE.OrthographicCamera(
      window.innerWidth / -2, window.innerWidth / 2,
      window.innerHeight / 2, window.innerHeight / -2,
      0.1, 1000
    );
    camera.position.z = 10;

    const centerLat = 14.233539920666581;
    const centerLon = 121.15133389733768;
    const scale = 385000;

    let isDragging = false;
    let isRotating = false;
    let lastMouse = { x: 0, y: 0 };

    function convertToXY([lon, lat]) {
      const x = (lon - centerLon) * scale;
      const y = (lat - centerLat) * scale;
      return { x, y };
    }

    // Load map and wait for texture to be ready before proceeding
    const loader = new THREE.TextureLoader();
    loader.load('/assets/images/cabuyao_map_2000m.jpg', (texture) => {
      const mapWidth = texture.image.width;
      const mapHeight = texture.image.height;

      const geometry = new THREE.PlaneGeometry(mapWidth, mapHeight);
      const material = new THREE.MeshBasicMaterial({ map: texture });
      const mapPlane = new THREE.Mesh(geometry, material);
      scene.add(mapPlane);

      navigator.geolocation.watchPosition(
        (position) => {
          const startCoord = [position.coords.longitude, position.coords.latitude];
          console.log(startCoord);
          
        }
      );
      // Get current location and draw route
      navigator.geolocation.getCurrentPosition(
        (position) => {
          /// geolocation coordinates
          // const startCoord = [position.coords.longitude, position.coords.latitude];

          ///Gate Coordinates
          const startCoord = [121.1498611, 14.2343056];
          const {x,y} = convertToXY(startCoord)

          const greenDot = new THREE.Mesh(
            new THREE.CircleGeometry(13,44),
            new THREE.MeshBasicMaterial({ color: 0x00ff00 })
          );
          greenDot.position.set(x,y,1);
          scene.add(greenDot);
          loadAndDrawPoints(startCoord);
        },
        (error) => console.error("Geolocation failed:", error),
        { enableHighAccuracy: true, timeout: 5000 }
      );
    });

    function loadAndDrawPoints(startCoord) {
      fetch('/assets/json/points.json')
        .then(res => res.json())
        .then(data => {
          const points = data.points;
          const pointMap = new Map();
          const coordMap = new Map();

          points.forEach(p => {
            pointMap.set(p.id, p.points);
            coordMap.set(p.id, p.coordinates);
          });

          const targetCoord = [121.14994, 14.232900];
          
          function findNearestPointId(coord) {
            let nearestId = null;
            let minDist = Infinity;
            for (const [id, coords] of coordMap.entries()) {
              if (!coords || coords.length < 2) continue;
              const [lon, lat] = coords;
              const dx = lon - coord[0];
              const dy = lat - coord[1];
              const dist = dx * dx + dy * dy;
              if (dist < minDist) {
                minDist = dist;
                nearestId = id;
              }
            }
            return nearestId;
          }

          const startId = findNearestPointId(startCoord);
          const targetId = findNearestPointId(targetCoord);

          const visited = new Set();
          const parent = new Map();
          const queue = [startId];
          visited.add(startId);

          while (queue.length > 0) {
            const current = queue.shift();
            if (current === targetId) break;
            const neighbors = pointMap.get(current) || [];
            for (const neighbor of neighbors) {
              if (!visited.has(neighbor)) {
                visited.add(neighbor);
                parent.set(neighbor, current);
                queue.push(neighbor);
              }
            }
          }

          const path = [];
          let node = targetId;
          while (node !== undefined) {
            path.unshift(node);
            node = parent.get(node);
          }

          const linePoints = path.map(id => {
            const [lon, lat] = coordMap.get(id);
            const { x, y } = convertToXY([lon, lat]);
            return new THREE.Vector3(x, y, 0);
          });

          const positions = [];
          linePoints.forEach(p => positions.push(p.x, p.y, p.z));

          const lineGeometry = new LineGeometry();
          lineGeometry.setPositions(positions);

          const lineMaterial = new LineMaterial({
            color: 0x4285F4,
            linewidth: 8,
            worldUnits: false,
          });
          lineMaterial.resolution.set(window.innerWidth, window.innerHeight);

          const thickLine = new Line2(lineGeometry, lineMaterial);
          thickLine.computeLineDistances();
          scene.add(thickLine);

          const routeGeometry = new THREE.BufferGeometry().setFromPoints(linePoints);
          const routeMaterial = new THREE.LineBasicMaterial({ color: 0x4285F4,  });
          const routeLine = new THREE.Line(routeGeometry, routeMaterial);
          scene.add(routeLine);

          linePoints.forEach(pos => {
            const dot = new THREE.Mesh(
              new THREE.CircleGeometry(3, 12),
              new THREE.MeshBasicMaterial({ color: 0x4285F4 })
            );
            dot.position.set(pos.x, pos.y, 1.5);
            scene.add(dot);
          });

          const { x: tx, y: ty } = convertToXY(targetCoord);
          const spriteMap = new THREE.TextureLoader().load('/assets/stickers/location_pin.png');
          const spriteMaterial = new THREE.SpriteMaterial({ map: spriteMap, transparent: true });
          const pinSprite = new THREE.Sprite(spriteMaterial);
          pinSprite.scale.set(32, 32, 1);
          pinSprite.position.set(tx, ty + 15, 3);
          scene.add(pinSprite);
        });
    }

    function animate() {
      requestAnimationFrame(animate);
      renderer.render(scene, camera);
    }
    animate();

    /// Mouse Listeners
    window.addEventListener('resize', () => {
      const w = window.innerWidth;
      const h = window.innerHeight;
      renderer.setSize(w, h);
      camera.left = w / -2;
      camera.right = w / 2;
      camera.top = h / 2;
      camera.bottom = h / -2;
      camera.updateProjectionMatrix();
    });

    canvas.addEventListener("mousedown", (e) => {
      lastMouse.x = e.clientX;
      lastMouse.y = e.clientY;
      if (e.button === 0) isDragging = true;
      else if (e.button === 2) isRotating = true;
    });

    window.addEventListener("mouseup", () => {
      isDragging = false;
      isRotating = false;
    });

    window.addEventListener("mousemove", (e) => {
      const dx = e.clientX - lastMouse.x;
      const dy = e.clientY - lastMouse.y;
      lastMouse.x = e.clientX;
      lastMouse.y = e.clientY;
      if (isDragging) {
        camera.position.x -= dx / camera.zoom;
        camera.position.y += dy / camera.zoom;
      }
      if (isRotating) {
        scene.rotation.z += dx * 0.005;
      }
    });

    canvas.addEventListener('wheel', (e) => {
      e.preventDefault();
      const zoomSpeed = 0.1;
      camera.zoom += e.deltaY > 0 ? -zoomSpeed : zoomSpeed;
      camera.zoom = Math.max(0.5, Math.min(5, camera.zoom));
      camera.updateProjectionMatrix();
    }, { passive: false });

    canvas.addEventListener("contextmenu", (e) => e.preventDefault());
  </script>
</body>

</html>