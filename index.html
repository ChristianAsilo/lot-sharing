<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <title>Cabuyao Map with Points</title>
  <style>
    html,
    body {
      margin: 0;
      overflow: hidden;
      width: 100%;
      height: 100%;
    }

    canvas {
      display: block;
    }
  </style>
</head>

<body>
  <canvas id="webgl"></canvas>

  <script type="module">
    import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.160.1/build/three.module.js';

    const canvas = document.getElementById('webgl');
    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);

    const scene = new THREE.Scene();

    const camera = new THREE.OrthographicCamera(
      window.innerWidth / -2,
      window.innerWidth / 2,
      window.innerHeight / 2,
      window.innerHeight / -2,
      0.1,
      1000
    );
    camera.position.z = 10;

    // ✅ Central reference (adjust if your map is centered differently)
    const centerLat =   14.233539920666581
    const centerLon = 121.15133389733768
    const scale = 385000; //
    let isDragging = false;
    let lastMouse = { x: 0, y: 0 };
    let mapWidth = 0;
    let mapHeight = 0;
      let isRotating = false;
      let lastRotateX = 0;

    // ✅ Convert lat/lon to pixel coordinates centered on centerLat/centerLon
    function convertToXY([lon, lat]) {
      const x = (lon - centerLon) * scale;
      const y = (lat - centerLat) * scale;
      return { x, y };
    }

    // Load map texture
    const loader = new THREE.TextureLoader();
    loader.load('/assets/images/cabuyao_map_2000m.jpg', (texture) => {
      mapWidth = texture.image.width;
      mapHeight = texture.image.height;

      // Add map as plane
      const geometry = new THREE.PlaneGeometry(mapWidth, mapHeight);
      const material = new THREE.MeshBasicMaterial({ map: texture });
      const mapPlane = new THREE.Mesh(geometry, material);
      mapPlane.position.set(0, 0, 0);
      scene.add(mapPlane);

      
      // ✅ Add green dot from DMS converted to decimal
      const greenLat = 14.2343056;  
      const greenLon = 121.1498611;  
      const { x: gx, y: gy } = convertToXY([greenLon, greenLat]);

      const greenDot = new THREE.Mesh(
        new THREE.CircleGeometry(6, 24),
        new THREE.MeshBasicMaterial({ color: 0x00ff00 }) 
      );
      greenDot.position.set(gx, gy, 2);
      scene.add(greenDot);

      // ✅ Now draw other red points
      loadAndDrawPoints();
    });

      function loadAndDrawPoints() {
        fetch('/assets/json/points.json')
          .then(res => res.json())
          .then(data => {
            const points = data.points;
            const pointMap = new Map();
            const coordMap = new Map();

            // Prepare map of points and coordinates
            points.forEach(p => {
              pointMap.set(p.id, p.points);  // neighbor connections
              coordMap.set(p.id, p.coordinates); // lat/lon
            });

            // ✅ Set start (green) and target point ID
            const startCoord = [121.1498611, 14.2343056];
            const targetCoord = [ 121.153202, 14.233498,]
        

            function findNearestPointId(coord) {
              let nearestId = null;
              let minDist = Infinity;

              for (const [id, [lon, lat]] of coordMap.entries()) {
                const dx = lon - coord[0];
                const dy = lat - coord[1];
                const dist = dx * dx + dy * dy;
                if (dist < minDist) {
                  minDist = dist;
                  nearestId = id;
                }
              }

              return nearestId;
            }

            const startId = findNearestPointId(startCoord);
            const targetId = findNearestPointId(targetCoord);
            
            // Find nearest point to green dot
            for (const [id, coord] of coordMap.entries()) {
              const dx = coord[0] - startCoord[0];
              const dy = coord[1] - startCoord[1];
              const dist = Math.sqrt(dx * dx + dy * dy);
              if (startId === null || dist < coordMap.get(startId).dist) {
                coordMap.get(id).dist = dist;
                startId = id;
              }
            }

 

            // ✅ BFS to find path from green (startId) to targetId
            const visited = new Set();
            const parent = new Map();
            const queue = [startId];

            visited.add(startId);

            while (queue.length > 0) {
              const current = queue.shift();
              if (current === targetId) break;

              const neighbors = pointMap.get(current) || [];
              for (const neighbor of neighbors) {
                if (!visited.has(neighbor)) {
                  visited.add(neighbor);
                  parent.set(neighbor, current);
                  queue.push(neighbor);
                }
              }
            }

            // ✅ Backtrack to get path
            const path = [];
            let node = targetId;
            while (node !== undefined) {
              path.unshift(node);
              node = parent.get(node);
            }

            // ✅ Draw path as connected line
            const linePoints = path.map(id => {
              const [lon, lat] = coordMap.get(id);
              const { x, y } = convertToXY([lon, lat]);
              return new THREE.Vector3(x, y, 1);
            });

            const routeGeometry = new THREE.BufferGeometry().setFromPoints(linePoints);
            const routeMaterial = new THREE.LineBasicMaterial({ color: 0x0000ff, linewidth: 2 });
            const routeLine = new THREE.Line(routeGeometry, routeMaterial);
            scene.add(routeLine);

            // ✅ Optional: draw dots on the path
            linePoints.forEach(pos => {
              const dot = new THREE.Mesh(
                new THREE.CircleGeometry(3, 12),
                new THREE.MeshBasicMaterial({ color: 0x0000FF, })
              );
              dot.position.set(pos.x, pos.y, 1.5);
              scene.add(dot);
            });

            const { x: tx, y: ty } = convertToXY(targetCoord);
            const spriteMap = new THREE.TextureLoader().load('/assets/stickers/location_pin.png');
            const spriteMaterial = new THREE.SpriteMaterial({ map: spriteMap, transparent: true });
            const pinSprite = new THREE.Sprite(spriteMaterial);
            pinSprite.scale.set(32, 32, 1); 
            pinSprite.position.set(tx, ty + 15, 3); 
            scene.add(pinSprite);

            
            
          });
      }


    function animate() {
      requestAnimationFrame(animate);
      renderer.render(scene, camera);
    }

    animate();

    window.addEventListener('resize', () => {
      const w = window.innerWidth;
      const h = window.innerHeight;
      renderer.setSize(w, h);
      camera.left = w / -2;
      camera.right = w / 2;
      camera.top = h / 2;
      camera.bottom = h / -2;
      camera.updateProjectionMatrix();
    });
    canvas.addEventListener("mousedown", (e) => {
        lastMouse.x = e.clientX;
        lastMouse.y = e.clientY;

        if (e.button === 0) {
          isDragging = true; // Left click
        } else if (e.button === 2) {
          isRotating = true; // Right click
        }
      });


      window.addEventListener("mouseup", () => {
          isDragging = false;
          isRotating = false;
        });


        window.addEventListener("mousemove", (e) => {
            const dx = e.clientX - lastMouse.x;
            const dy = e.clientY - lastMouse.y;
            lastMouse.x = e.clientX;
            lastMouse.y = e.clientY;

            if (isDragging) {
              // Move camera (panning)
              camera.position.x -= dx / camera.zoom;
              camera.position.y += dy / camera.zoom;
            }

            if (isRotating) {
              // Rotate scene
              scene.rotation.z += dx * 0.005; // Adjust speed as needed
            }
          });


        canvas.addEventListener('wheel', (e) => {
          e.preventDefault();
          const zoomSpeed = 0.1;
          camera.zoom += e.deltaY > 0 ? -zoomSpeed : zoomSpeed;
          camera.zoom = Math.max(0.5, Math.min(5, camera.zoom));
          camera.updateProjectionMatrix();
        }, { passive: false });

          canvas.addEventListener("contextmenu", (e) => e.preventDefault());

  </script>
</body>

</html>